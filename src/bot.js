// src/bot.js - ƒåist√Ω k√≥d pro v0.16 architekturu s integrac√≠ modul≈Ø

require('dotenv').config();

// Import pot≈ôebn√Ωch t≈ô√≠d a modul≈Ø z discord.js a dal≈°√≠ch soubor≈Ø projektu
const { Client, GatewayIntentBits, Collection, ActivityType } = require('discord.js');
// Pokud m√°≈° config.js v ../config/config.js a pou≈æ√≠v√°≈° ho, m≈Ø≈æe≈° ho importovat zde.
const config = require('../config/config'); // P≈ô√≠klad importu config souboru

const path = require('path');
const fs = require('fs');

const registerCommands = require('../bot_utilities/registerCommands'); // P≈ô√≠klad importu utility

// Import vlastn√≠ch modul≈Ø pro datab√°zi, zpracov√°n√≠ zpr√°v, spr√°vu pamƒõti a dashboard server
const db = require('./db/database'); // Modul pro pr√°ci s datab√°z√≠ - Cesta by mƒõla b√Ωt spr√°vn√°
const messageHandler = require('./features/messageHandler'); // Modul pro zpracov√°n√≠ p≈ô√≠choz√≠ch zpr√°v - Cesta by mƒõla b√Ωt spr√°vn√°
const memoryManager = require('./features/memoryManager'); // Modul pro spr√°vu pamƒõti a NPC - Cesta by mƒõla b√Ωt spr√°vn√°
const startDashboardServer = require('./web/server'); // Funkce pro spu≈°tƒõn√≠ dashboard serveru - Cesta by mƒõla b√Ωt spr√°vn√°


// Vytvo≈ôen√≠ nov√©ho Discord klienta s definovan√Ωmi z√°mƒõry (intents)
// Intents jsou kl√≠ƒçov√© pro urƒçen√≠, jak√© ud√°losti bude bot p≈ôij√≠mat.
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds, // Pot≈ôebn√© pro informace o serverech a rol√≠ch
        GatewayIntentBits.GuildMessages, // Pot≈ôebn√© pro ƒçten√≠ zpr√°v v kan√°lech
        GatewayIntentBits.MessageContent, // Pot≈ôebn√© pro p≈ô√≠stup k obsahu zpr√°v (VY≈ΩADUJE ZAPNUT√ç V DEVELOPER PORT√ÅLU)
        GatewayIntentBits.DirectMessages, // Pot≈ôebn√© pro pr√°ci s p≈ô√≠m√Ωmi zpr√°vami
        // Doporuƒçen√© Intenty pro lep≈°√≠ funkƒçnost:
        GatewayIntentBits.DirectMessageTyping, // Pro indik√°tor psan√≠ v DM
        GatewayIntentBits.GuildMessageTyping, // Pro indik√°tor psan√≠ v kan√°lech
        // M≈Ø≈æe≈° p≈ôidat i dal≈°√≠ podle pot≈ôeby, nap≈ô. GuildMembers, GuildPresences atd.
    ],
    partials: ['CHANNEL'], // D≈Øle≈æit√© pro spr√°vn√© zpracov√°n√≠ DM (soukrom√Ωch zpr√°v)
});

// Vytvo≈ôen√≠ kolekce pro ukl√°d√°n√≠ p≈ô√≠kaz≈Ø
client.commands = new Collection();

// Naƒç√≠t√°n√≠ soubor≈Ø p≈ô√≠kaz≈Ø z adres√°≈ôe 'commands'
const commandsPath = path.join(__dirname, 'commands'); // Cesta ke slo≈æce s p≈ô√≠kazy (relativnƒõ k bot.js, kter√Ω je v src/)
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js') && file !== 'index.js'); // Filtrujeme jen .js soubory a ignorujeme index.js (pokud ho m√°≈°)

console.log('--- DEBUG bot.js: Naƒç√≠t√°m p≈ô√≠kazy...');
for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    try {
        const command = require(filePath);
        // Zkontrolujte, zda p≈ô√≠kaz m√° po≈æadovan√© vlastnosti 'data' a 'execute' (pro Slash Commands)
        if ('data' in command && 'execute' in command) {
            client.commands.set(command.data.name, command);
            console.log(`--- DEBUG bot.js: P≈ô√≠kaz ${command.data.name} naƒçten.`);
        } else {
            console.warn(`[VAROV√ÅN√ç] P≈ô√≠kaz na ${filePath} postr√°d√° po≈æadovanou vlastnost "data" nebo "execute".`);
        }
    } catch (error) {
        console.error(`‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ p≈ô√≠kazu z ${filePath}:`, error);
    }
}


// --- Event Handlers ---

// Event: Bot je p≈ôipraven a p≈ôihl√°≈°en k Discordu
// Pou≈æ√≠v√°me 'ready' jako n√°zev ud√°losti
client.once('ready', async readyClient => {
    console.log(`üî• Jsem p≈ôipraven√° a p≈ôihl√°≈°en√° jako ${readyClient.user.tag}!`);

    // M≈Ø≈æete zde nastavit status bota (nap≈ô. "Playing with data")
    readyClient.user.setPresence({
        activities: [{ name: 'new galaxies', type: ActivityType.Watching }], // ActivityType m≈Ø≈æe b√Ωt Playing, Streaming, Listening, Watching, Competing
        status: 'dnd', // Status m≈Ø≈æe b√Ωt online, idle, dnd (Do Not Disturb), invisible
    });


    // === Inicializaƒçn√≠ √∫koly, kter√© se spust√≠ POUZE JEDNOU po startu ===

    // 1. P≈ôipojen√≠ k datab√°zi
    console.log('--- DEBUG bot.js: Vstupuji do DB connect bloku v ready handleru.');
    try {
        await db.connect(); // Vol√°me asynchronn√≠ funkci connect z db modulu
        console.log('--- DEBUG bot.js: DB connect se dokonƒçilo.');

        // 2. Naƒçten√≠ NPC konfigurac√≠ do pamƒõti
        console.log('--- DEBUG bot.js: Vol√°m memoryManager.loadNpcConfigs(); ---');
        await memoryManager.loadNpcConfigs(); // Vol√°me asynchronn√≠ funkci z memoryManageru
        console.log('--- DEBUG bot.js: Vol√°n√≠ memoryManager.loadNpcConfigs() se dokonƒçilo.');

        // 3. Synchronizace NPC konfigurac√≠ s DB (pokud existuj√≠ nov√©/zmƒõnƒõn√©)
         console.log('--- DEBUG bot.js: Vol√°m db.syncNpcConfigs(); ---');
         const npcConfigs = memoryManager.getNpcConfigs(); // Z√≠sk√°me aktu√°ln√≠ NPC configs z memoryManageru
         await db.syncNpcConfigs(npcConfigs); // Vol√°me asynchronn√≠ funkci z db modulu
         console.log('--- DEBUG bot.js: Vol√°n√≠ db.syncNpcConfigs() se dokonƒçilo.');


        // 4. Naƒçten√≠ aktivn√≠ch kan√°l≈Ø z DB do cache memoryManageru
        console.log('--- DEBUG bot.js: Vol√°m memoryManager.loadActiveChannelsFromDb(); ---');
        await memoryManager.loadActiveChannelsFromDb(); // Vol√°me asynchronn√≠ funkci z memoryManageru
        console.log('--- DEBUG bot.js: Vol√°n√≠ memoryManager.loadActiveChannelsFromDb() se dokonƒçilo.');

        // 5. Spu≈°tƒõn√≠ dashboard serveru
        console.log('--- DEBUG bot.js: Inicializaƒçn√≠ √∫koly po startu dokonƒçeny.');
        console.log('--- DEBUG bot.js: Pokou≈°√≠m se spustit dashboard server...');
        try {
            startDashboardServer(client, db, memoryManager); // P≈ôed√°v√°me z√°vislosti dashboard serveru
            console.log('--- DEBUG bot.js: Funkce startDashboardServer vol√°na.');
            // Samotn√Ω console.log o spu≈°tƒõn√≠ Express serveru (naslouch√°n√≠ na portu) by mƒõl b√Ωt uvnit≈ô server.js
        } catch (dashboardError) {
            console.error('‚ùå Chyba p≈ôi spou≈°tƒõn√≠ dashboard serveru:', dashboardError);
            // Logujeme chybu, pokud se server nespust√≠, ale nech√°me bota bƒõ≈æet
        }
        // === Konec inicializaƒçn√≠ch √∫kol≈Ø ===


    } catch (error) {
        console.error('‚ùå Kritick√° chyba p≈ôi inicializaci bota:', error);
        // Pokud sel≈æe p≈ôipojen√≠ k DB nebo naƒçten√≠ z√°kladn√≠ch dat, bot nem≈Ø≈æe fungovat
        // Zalogujeme chybu a ukonƒç√≠me proces s chybov√Ωm k√≥dem
        process.exit(1);
    }
});


// Event: Zpracov√°n√≠ interakc√≠ (Slash Commands, Context Menu Commands atd.)
// Pou≈æ√≠v√°me 'interactionCreate' jako n√°zev ud√°losti
client.on('interactionCreate', async interaction => {
    // Zkontrolujeme, zda se jedn√° o p≈ô√≠kaz typu ChatInput (slash command)
    if (!interaction.isChatInputCommand()) {
        // Pokud se nejedn√° o ChatInput Command, zkontrolujeme, zda je to Autocomplete interakce
        if (interaction.isAutocomplete()) {
             // console.log(`--- DEBUG bot.js: U≈æivatel ${interaction.user.tag} spou≈°t√≠ Autocomplete pro p≈ô√≠kaz /${interaction.commandName}`); // P≈ô√≠li≈° ƒçast√© logov√°n√≠
             const command = interaction.client.commands.get(interaction.commandName);
             if (!command) {
                 // console.error(`Autocomplete pro p≈ô√≠kaz ${interaction.commandName} nebyl nalezen.`); // Tato chyba by se mƒõla logovat, pokud command neexistuje v≈Øbec
                 return;
             }
             try {
                 // Zkontrolujeme, zda naƒçten√Ω p≈ô√≠kaz m√° metodu 'autocomplete' a zavol√°me ji
                 if (command.autocomplete) {
                     await command.autocomplete(interaction);
                 }
             } catch (error) {
                 console.error(`‚ùå Chyba p≈ôi prov√°dƒõn√≠ Autocomplete pro p≈ô√≠kaz /${interaction.commandName}:`, error);
                 // Chyba v autocomplete by nemƒõla crashovat bota, ale ovlivn√≠ to u≈æivatelskou zku≈°enost
             }
        }
        return; // Ignorujeme ostatn√≠ typy interakc√≠, pokud nejsou explicitnƒõ zpracov√°ny
    }


    // Z√≠sk√°n√≠ p≈ô√≠kazu z kolekce podle jeho n√°zvu
    const command = interaction.client.commands.get(interaction.commandName);

    // Pokud p≈ô√≠kaz neexistuje v kolekci, zalogujeme chybu a ukonƒç√≠me zpracov√°n√≠
    if (!command) {
        console.error(`P≈ô√≠kaz ${interaction.commandName} nebyl nalezen v kolekci p≈ô√≠kaz≈Ø.`);
        return;
    }

    // Logov√°n√≠ pou≈æit√≠ p≈ô√≠kazu
    console.log(`U≈æivatel ${interaction.user.tag} (${interaction.user.id}) pou≈æil p≈ô√≠kaz /${interaction.commandName}`
        + (interaction.guild ? ` v kan√°lu ${interaction.channelId} na serveru ${interaction.guildId}.` : ` v DM.`) // P≈ôid√°no rozli≈°en√≠, zda p≈ô√≠kaz byl pou≈æit na serveru nebo v DM
    );


    // Spu≈°tƒõn√≠ logiky p≈ô√≠kazu a zachycen√≠ p≈ô√≠padn√Ωch chyb
    try {
        await command.execute(interaction); // Vol√°me asynchronn√≠ metodu execute p≈ô√≠kazu
    } catch (error) {
        console.error(`‚ùå Chyba p≈ôi prov√°dƒõn√≠ p≈ô√≠kazu /${interaction.commandName}:`, error);
        // Odesl√°n√≠ chybov√© zpr√°vy u≈æivateli, pokud interakce ji≈æ nebyla zodpovƒõzena nebo odlo≈æena
        if (interaction.replied || interaction.deferred) {
            // Pokud u≈æ interakce byla zodpovƒõzena nebo odlo≈æena, pou≈æijeme followUp
            await interaction.followUp({ content: 'P≈ôi prov√°dƒõn√≠ tohoto p≈ô√≠kazu do≈°lo k chybƒõ!', ephemeral: true });
        } else {
            // Jinak odpov√≠me p≈ô√≠mo (reply)
            await interaction.reply({ content: 'P≈ôi prov√°dƒõn√≠ tohoto p≈ô√≠kazu do≈°lo k chybƒõ!', ephemeral: true });
        }
    }
});

// Event: Zpracov√°n√≠ p≈ô√≠choz√≠ch zpr√°v (pro reakci bota v aktivn√≠ch kan√°lech nebo DM)
// Pou≈æ√≠v√°me 'messageCreate' jako n√°zev ud√°losti
// P≈ôi ka≈æd√© zpr√°vƒõ se zavol√° funkce handleChatMessage z modulu messageHandler
client.on('messageCreate', messageHandler.handleChatMessage);


// Graceful shutdown - Zaji≈°tƒõn√≠, ≈æe se bot vypne ƒçistƒõ p≈ôi p≈ôijet√≠ sign√°lu SIGINT (nap≈ô. Ctrl+C, 'pm2 stop', 'pm2 restart')
process.on('SIGINT', async () => {
    console.log('P≈ôijat sign√°l SIGINT. Vyp√≠n√°m bota...');
    try {
        // TODO: Pokud Express server v server.js nem√° vlastn√≠ obsluhu SIGINT, zva≈æte jeho explicitn√≠ vypnut√≠ zde.
        // Nap≈ô√≠klad, pokud startDashboardServer vrac√≠ instanci serveru:
        // if (dashboardServerInstance) {
        //    await dashboardServerInstance.close();
        //    console.log('Dashboard server ukonƒçen.');
        // }

        // Ukonƒçen√≠ spojen√≠ s Discordem
        // Kontrola, zda je klient a jeho p≈ôipojen√≠ platn√© a p≈ôipojen√© (status 0 = Ready) p≈ôed pokusem o ukonƒçen√≠ spojen√≠
        if (client && client.ws && client.ws.status === 0) {
             console.log('Ukonƒçuji spojen√≠ s Discordem...');
             client.destroy(); // Spr√°vn√° metoda pro ukonƒçen√≠ Discord spojen√≠ klienta
             console.log('Spojen√≠ s Discordem ukonƒçeno.');
        } else {
            console.log('Discord klient nen√≠ p≈ôipojen nebo ji≈æ ukonƒçuje spojen√≠.');
        }


        // Uzav≈ôen√≠ datab√°zov√©ho spojen√≠
        console.log('Ukonƒçuji spojen√≠ s datab√°zi...');
        // Vol√°me SPR√ÅVNOU asynchronn√≠ funkci db.close() a ƒçek√°me na jej√≠ dokonƒçen√≠
        await db.close(); // <<< Ujistƒõte se, ≈æe db.close() v database.js je asynchronn√≠ a spr√°vnƒõ uzav√≠r√° pool/spojen√≠
        console.log('Spojen√≠ s datab√°zi ukonƒçeno.');


        console.log('Bot vypnut.');
        process.exit(0); // Ukonƒç√≠ proces s k√≥dem 0 (√∫spƒõch)
        // POZOR: Nƒõkdy pm2 pot≈ôebuje chvilku, ne≈æ zaznamen√°, ≈æe proces skonƒçil.
        // Pokud m√°te probl√©my s rychl√Ωm restartem v pm2, m≈Ø≈æe pomoct mal√© zpo≈ædƒõn√≠ P≈òED process.exit(0), ale obecnƒõ by to nemƒõlo b√Ωt nutn√© s asynchronn√≠mi operacemi jako db.close() a client.destroy().

    } catch (error) {
        console.error('‚ùå Chyba p≈ôi ƒçist√©m vyp√≠n√°n√≠ bota:', error);
        process.exit(1); // Ukonƒç√≠ proces s k√≥dem 1 (chyba)
    }
});

// Zpracov√°n√≠ neo≈°et≈ôen√Ωch v√Ωjimek (chyb, kter√© se staly synchronnƒõ a nikde nebyly zachyceny blokem try...catch)
process.on('uncaughtException', (error) => {
    console.error('‚ùå Nezachycen√° synchronn√≠ v√Ωjimka:', error);
    // V produkƒçn√≠m prost≈ôed√≠ byste zde mohli cht√≠t logovat chybu do souboru nebo extern√≠ slu≈æby.
    // Zv√°≈æit, zda po kritick√© chybƒõ proces ukonƒçit:
    // process.exit(1);
});

// Zpracov√°n√≠ neo≈°et≈ôen√Ωch odm√≠tnut√≠ Promise (asynchronn√≠ chyby, kter√© nebyly zachyceny .catch())
process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Neo≈°et≈ôen√© odm√≠tnut√≠ Promise:', reason, promise);
    // Zde byste tak√© mohli logovat.
    // Zv√°≈æit, zda po kritick√© chybƒõ proces ukonƒçit:
    // process.exit(1);
});


// P≈ôihl√°≈°en√≠ bota k Discordu pomoc√≠ tokenu z promƒõnn√Ωch prost≈ôed√≠ (.env)
// Toto je posledn√≠ krok p≈ôi startu bota.
client.login(process.env.DISCORD_TOKEN);